<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        /* ... (keep previous CSS styles) ... */
    </style>
</head>
<body>
    <div class="game-info">
        Current Turn: <span id="current-turn">White</span>
    </div>
    <div class="container">
        <div class="captured-pieces" id="captured-black">
            <h3>Black Captured:</h3>
        </div>
        <div class="chess-board" id="board"></div>
        <div class="captured-pieces" id="captured-white">
            <h3>White Captured:</h3>
        </div>
    </div>
    <div id="game-over" class="game-over">
        <h2 id="winner-text"></h2>
        <button class="restart-btn" onclick="location.reload()">New Game</button>
    </div>

    <script>
        class ChessGame {
            constructor() {
                this.board = document.getElementById('board');
                this.selectedPiece = null;
                this.currentPlayer = 'white';
                this.capturedWhite = [];
                this.capturedBlack = [];
                this.gameActive = true;
                this.initializeBoard();
                this.createPieces();
                this.updateTurnDisplay();
            }

            initializeBoard() {
                this.board.innerHTML = '';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        square.addEventListener('click', (e) => this.handleSquareClick(e));
                        this.board.appendChild(square);
                    }
                }
            }

            createPieces() {
                const initialPosition = [
                    ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
                    ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
                    ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
                ];

                const squares = this.board.children;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = initialPosition[row][col];
                        const index = row * 8 + col;
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = 'piece';
                            pieceElement.textContent = piece;
                            pieceElement.style.color = row < 2 ? 'black' : 'white';
                            pieceElement.dataset.type = this.getPieceType(piece);
                            squares[index].appendChild(pieceElement);
                        }
                    }
                }
            }

            handleSquareClick(event) {
                if (!this.gameActive) return;

                const square = event.currentTarget;
                const piece = square.querySelector('.piece');

                if (this.selectedPiece) {
                    if (square === this.selectedPiece.square) {
                        this.clearSelection();
                        return;
                    }

                    if (this.isValidMove(this.selectedPiece.square, square)) {
                        this.movePiece(this.selectedPiece.square, square);
                        this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                        this.updateTurnDisplay();
                    }
                    this.clearSelection();
                } else if (piece && this.isCorrectPlayer(piece)) {
                    this.selectedPiece = { square, element: piece };
                    square.classList.add('selected');
                    this.showPossibleMoves(square);
                }
            }

            isValidMove(fromSquare, toSquare) {
                const fromPiece = fromSquare.querySelector('.piece');
                const toPiece = toSquare.querySelector('.piece');
                const pieceType = fromPiece.dataset.type;
                const fromRow = parseInt(fromSquare.dataset.row);
                const fromCol = parseInt(fromSquare.dataset.col);
                const toRow = parseInt(toSquare.dataset.row);
                const toCol = parseInt(toSquare.dataset.col);
                const deltaRow = toRow - fromRow;
                const deltaCol = toCol - fromCol;
                const color = fromPiece.style.color;

                // Prevent capturing own pieces
                if (toPiece && toPiece.style.color === color) return false;

                switch(pieceType) {
                    case 'pawn':
                        const direction = color === 'white' ? -1 : 1;
                        const startRow = color === 'white' ? 6 : 1;
                        
                        // Regular move
                        if (fromCol === toCol && !toPiece) {
                            if (deltaRow === direction) return true;
                            if (fromRow === startRow && deltaRow === 2 * direction && 
                                !this.isPieceBetween(fromRow, fromCol, toRow, toCol)) return true;
                        }
                        
                        // Capture move
                        if (Math.abs(deltaCol) === 1 && deltaRow === direction && toPiece) return true;
                        break;

                    case 'rook':
                        if (fromRow !== toRow && fromCol !== toCol) return false;
                        return this.isPathClear(fromRow, fromCol, toRow, toCol);

                    case 'knight':
                        return (Math.abs(deltaRow) === 2 && Math.abs(deltaCol) === 1) ||
                               (Math.abs(deltaRow) === 1 && Math.abs(deltaCol) === 2);

                    case 'bishop':
                        if (Math.abs(deltaRow) !== Math.abs(deltaCol)) return false;
                        return this.isPathClear(fromRow, fromCol, toRow, toCol);

                    case 'queen':
                        if (fromRow !== toRow && fromCol !== toCol && 
                            Math.abs(deltaRow) !== Math.abs(deltaCol)) return false;
                        return this.isPathClear(fromRow, fromCol, toRow, toCol);

                    case 'king':
                        return Math.abs(deltaRow) <= 1 && Math.abs(deltaCol) <= 1;
                }

                return true;
            }

            isPathClear(fromRow, fromCol, toRow, toCol) {
                const rowStep = Math.sign(toRow - fromRow);
                const colStep = Math.sign(toCol - fromCol);
                let currentRow = fromRow + rowStep;
                let currentCol = fromCol + colStep;

                while (currentRow !== toRow || currentCol !== toCol) {
                    const index = currentRow * 8 + currentCol;
                    if (this.board.children[index].querySelector('.piece')) return false;
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                return true;
            }

            isPieceBetween(fromRow, fromCol, toRow, toCol) {
                const rowStep = Math.sign(toRow - fromRow);
                const colStep = Math.sign(toCol - fromCol);
                let currentRow = fromRow + rowStep;
                let currentCol = fromCol + colStep;

                while (currentRow !== toRow || currentCol !== toCol) {
                    const index = currentRow * 8 + currentCol;
                    if (this.board.children[index].querySelector('.piece')) return true;
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                return false;
            }

            movePiece(fromSquare, toSquare) {
                const piece = fromSquare.querySelector('.piece');
                const targetPiece = toSquare.querySelector('.piece');

                if (targetPiece) {
                    this.capturePiece(targetPiece);
                }

                toSquare.appendChild(piece);
                
                // Check for king capture
                if (targetPiece?.dataset.type === 'king') {
                    this.showGameOver(piece.style.color === 'white' ? 'White' : 'Black');
                }
            }

            capturePiece(piece) {
                const capturedDiv = piece.style.color === 'white' 
                    ? document.getElementById('captured-white') 
                    : document.getElementById('captured-black');

                const capturedElement = document.createElement('div');
                capturedElement.className = 'captured-piece';
                capturedElement.textContent = piece.textContent;
                capturedDiv.appendChild(capturedElement);
            }

            showGameOver(winner) {
                this.gameActive = false;
                document.getElementById('game-over').style.display = 'block';
                document.getElementById('winner-text').textContent = `${winner} Wins!`;
            }

            updateTurnDisplay() {
                document.getElementById('current-turn').textContent = 
                    this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1);
            }

            isCorrectPlayer(piece) {
                return piece.style.color === this.currentPlayer;
            }

            getPieceType(piece) {
                const types = {
                    '♔': 'king', '♚': 'king',
                    '♕': 'queen', '♛': 'queen',
                    '♖': 'rook', '♜': 'rook',
                    '♗': 'bishop', '♝': 'bishop',
                    '♘': 'knight', '♞': 'knight',
                    '♙': 'pawn', '♟': 'pawn'
                };
                return types[piece.textContent];
            }

            showPossibleMoves(square) {
                const allSquares = document.getElementsByClassName('square');
                Array.from(allSquares).forEach(sq => {
                    if (this.isValidMove(square, sq)) {
                        sq.classList.add('possible-move');
                    }
                });
            }

            clearSelection() {
                if (this.selectedPiece) {
                    this.selectedPiece.square.classList.remove('selected');
                    this.selectedPiece = null;
                }
                this.clearPossibleMoves();
            }

            clearPossibleMoves() {
                Array.from(document.getElementsByClassName('square'))
                    .forEach(sq => sq.classList.remove('possible-move'));
            }
        }

        // Initialize the game
        const game = new ChessGame();
    </script>
</body>
</html>
