<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 2px solid #333;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
        }

        .square:nth-child(odd) {
            background-color: #769656;
        }

        .square:nth-child(even) {
            background-color: #eeeed2;
        }

        .piece {
            pointer-events: none; /* Prevent clicking on the piece directly */
        }

        .selected {
            background-color: #a6a6a6 !important; /* Highlight selected square */
        }
    </style>
</head>
<body>
    <div id="chessboard"></div>

    <script>
        const chessboard = document.getElementById("chessboard");

        // Initialize the board with Unicode characters
        const initialBoard = [
            ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
            ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
            ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
        ];

        let currentPlayer = 'white'; // Track whose turn it is
        let selectedPiece = null;
        let enPassantTarget = null; // Track en passant target square
        let castlingRights = {
            white: { king: true, queen: true },
            black: { king: true, queen: true }
        };

        function createBoard() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement("div");
                    square.classList.add("square");
                    square.dataset.row = row;
                    square.dataset.col = col;

                    if (initialBoard[row][col]) {
                        const piece = document.createElement("div");
                        piece.classList.add("piece");
                        piece.textContent = initialBoard[row][col];
                        square.appendChild(piece);
                    }

                    square.addEventListener("click", () => handleSquareClick(row, col));
                    chessboard.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            const square = chessboard.children[row * 8 + col];
            const piece = square.querySelector(".piece");

            if (selectedPiece) {
                // Move the piece if valid
                if (isValidMove(selectedPiece, row, col)) {
                    movePiece(selectedPiece, row, col);
                    currentPlayer = currentPlayer === 'white' ? 'black' : 'white'; // Switch turns
                    checkGameStatus();
                }
                selectedPiece = null;
            } else if (piece && isPlayersPiece(piece.textContent, currentPlayer)) {
                // Select the piece if it belongs to the current player
                selectedPiece = { row, col, piece };
                square.classList.add("selected");
            }
        }

        function isPlayersPiece(piece, player) {
            return (player === 'white' && piece.charCodeAt(0) < 9818) || 
                   (player === 'black' && piece.charCodeAt(0) >= 9818);
        }

        function isValidMove(selected, targetRow, targetCol) {
            const piece = selected.piece.textContent;
            const startRow = selected.row;
            const startCol = selected.col;

            switch (piece) {
                case '♙': return isValidPawnMove(startRow, startCol, targetRow, targetCol, 'white');
                case '♟': return isValidPawnMove(startRow, startCol, targetRow, targetCol, 'black');
                case '♖': case '♜': return isValidRookMove(startRow, startCol, targetRow, targetCol);
                case '♘': case '♞': return isValidKnightMove(startRow, startCol, targetRow, targetCol);
                case '♗': case '♝': return isValidBishopMove(startRow, startCol, targetRow, targetCol);
                case '♕': case '♛': return isValidQueenMove(startRow, startCol, targetRow, targetCol);
                case '♔': case '♚': return isValidKingMove(startRow, startCol, targetRow, targetCol);
                default: return false;
            }
        }

        function movePiece(selected, targetRow, targetCol) {
            const startSquare = chessboard.children[selected.row * 8 + selected.col];
            const targetSquare = chessboard.children[targetRow * 8 + targetCol];

            // Remove any existing piece in the target square
            if (targetSquare.querySelector(".piece")) {
                targetSquare.removeChild(targetSquare.querySelector(".piece"));
            }

            // Handle en passant capture
            if (enPassantTarget && selected.piece.textContent === (currentPlayer === 'white' ? '♙' : '♟') &&
                targetRow === enPassantTarget.row && targetCol === enPassantTarget.col) {
                const capturedPawnRow = currentPlayer === 'white' ? targetRow + 1 : targetRow - 1;
                const capturedPawnSquare = chessboard.children[capturedPawnRow * 8 + targetCol];
                capturedPawnSquare.removeChild(capturedPawnSquare.querySelector(".piece"));
            }

            // Move the piece
            targetSquare.appendChild(selected.piece);
            startSquare.classList.remove("selected");

            // Update en passant target
            enPassantTarget = null;
            if (selected.piece.textContent === (currentPlayer === 'white' ? '♙' : '♟')) {
                if (Math.abs(selected.row - targetRow) === 2) {
                    enPassantTarget = { row: (selected.row + targetRow) / 2, col: targetCol };
                }
            }

            // Update castling rights
            if (selected.piece.textContent === '♔' || selected.piece.textContent === '♚') {
                castlingRights[currentPlayer].king = false;
                castlingRights[currentPlayer].queen = false;
            }
            if (selected.piece.textContent === '♖' || selected.piece.textContent === '♜') {
                if (selected.col === 0) castlingRights[currentPlayer].queen = false;
                if (selected.col === 7) castlingRights[currentPlayer].king = false;
            }
        }

        function isValidPawnMove(startRow, startCol, targetRow, targetCol, color) {
            const direction = color === 'white' ? -1 : 1;
            const startRank = color === 'white' ? 6 : 1;

            // Move forward one square
            if (startCol === targetCol && startRow + direction === targetRow && !getPieceAt(targetRow, targetCol)) {
                return true;
            }

            // Move forward two squares on the first move
            if (startCol === targetCol && startRow + 2 * direction === targetRow && startRow === startRank && !getPieceAt(targetRow, targetCol)) {
                return true;
            }

            // Capture diagonally
            if (Math.abs(startCol - targetCol) === 1 && startRow + direction === targetRow && getPieceAt(targetRow, targetCol)) {
                return true;
            }

            // En passant capture
            if (enPassantTarget && Math.abs(startCol - targetCol) === 1 && startRow + direction === targetRow &&
                targetRow === enPassantTarget.row && targetCol === enPassantTarget.col) {
                return true;
            }

            return false;
        }

        function isValidRookMove(startRow, startCol, targetRow, targetCol) {
            if (startRow !== targetRow && startCol !== targetCol) return false;
            return isPathClear(startRow, startCol, targetRow, targetCol);
        }

        function isValidKnightMove(startRow, startCol, targetRow, targetCol) {
            const rowDiff = Math.abs(startRow - targetRow);
            const colDiff = Math.abs(startCol - targetCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        }

        function isValidBishopMove(startRow, startCol, targetRow, targetCol) {
            if (Math.abs(startRow - targetRow) !== Math.abs(startCol - targetCol)) return false;
            return isPathClear(startRow, startCol, targetRow, targetCol);
        }

        function isValidQueenMove(startRow, startCol, targetRow, targetCol) {
            return isValidRookMove(startRow, startCol, targetRow, targetCol) ||
                   isValidBishopMove(startRow, startCol, targetRow, targetCol);
        }

        function isValidKingMove(startRow, startCol, targetRow, targetCol) {
            const rowDiff = Math.abs(startRow - targetRow);
            const colDiff = Math.abs(startCol - targetCol);
            return rowDiff <= 1 && colDiff <= 1;
        }

        function isPathClear(startRow, startCol, targetRow, targetCol) {
            const rowStep = targetRow > startRow ? 1 : targetRow < startRow ? -1 : 0;
            const colStep = targetCol > startCol ? 1 : targetCol < startCol ? -1 : 0;

            let row = startRow + rowStep;
            let col = startCol + colStep;

            while (row !== targetRow || col !== targetCol) {
                if (getPieceAt(row, col)) return false;
                row += rowStep;
                col += colStep;
            }

            return true;
        }

        function getPieceAt(row, col) {
            const square = chessboard.children[row * 8 + col];
            return square.querySelector(".piece")?.textContent || null;
        }

        function checkGameStatus() {
            const kingPosition = findKing(currentPlayer);
            if (isInCheck(kingPosition.row, kingPosition.col, currentPlayer)) {
                if (hasLegalMoves(currentPlayer)) {
                    alert(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} is in check!`);
                } else {
                    alert(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} is checkmated!`);
                    resetGame();
                }
            } else if (!hasLegalMoves(currentPlayer)) {
                alert("Stalemate!");
                resetGame();
            }
        }

        function isInCheck(row, col, player) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = getPieceAt(r, c);
                    if (piece && !isPlayersPiece(piece, player) && isValidMove({ row: r, col: c, piece }, row, col)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function hasLegalMoves(player) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = getPieceAt(r, c);
                    if (piece && isPlayersPiece(piece, player)) {
                        for (let tr = 0; tr < 8; tr++) {
                            for (let tc = 0; tc < 8; tc++) {
                                if (isValidMove({ row: r, col: c, piece }, tr, tc)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        function findKing(player) {
            const king = player === 'white' ? '♔' : '♚';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (getPieceAt(r, c) === king) {
                        return { row: r, col: c };
                    }
                }
            }
        }

        function resetGame() {
            chessboard.innerHTML = '';
            createBoard();
            currentPlayer = 'white';
            selectedPiece = null;
            enPassantTarget = null;
            castlingRights = {
                white: { king: true, queen: true },
                black: { king: true, queen: true }
            };
        }

        createBoard();
    </script>
</body>
</html>
